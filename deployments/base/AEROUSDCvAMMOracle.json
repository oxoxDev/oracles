{
  "address": "0xbF8216841B3c3032381BD3f7233895Fe3b5BDCfB",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "amm",
      "outputs": [
        {
          "internalType": "contract IAerodromeVAMM",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IAggregatorInterface",
          "name": "oracle",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "getPx",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "latestAnswer",
      "outputs": [
        {
          "internalType": "int256",
          "name": "",
          "type": "int256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "offset",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "priceFeed0",
      "outputs": [
        {
          "internalType": "contract IAggregatorInterface",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "priceFeed1",
      "outputs": [
        {
          "internalType": "contract IAggregatorInterface",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "x",
          "type": "uint256"
        }
      ],
      "name": "sqrt",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "y",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "token0",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "token1",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x72737702e1b687f5b57dfa13d03abc29f5b313d32c2073e3d87a813ae77b2804",
  "receipt": {
    "to": null,
    "from": "0x0F6e98A756A40dD050dC78959f45559F98d3289d",
    "contractAddress": "0xbF8216841B3c3032381BD3f7233895Fe3b5BDCfB",
    "transactionIndex": 62,
    "gasUsed": "856118",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x0a69ea2841d107155aaa19244b76d4cda9d5acbdd77fc086894d69c1434f868c",
    "transactionHash": "0x72737702e1b687f5b57dfa13d03abc29f5b313d32c2073e3d87a813ae77b2804",
    "logs": [],
    "blockNumber": 20367893,
    "cumulativeGasUsed": "10600928",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "31f09566fda8f3faaa054f3e12d9b2cb",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"amm\",\"outputs\":[{\"internalType\":\"contract IAerodromeVAMM\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAggregatorInterface\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getPx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestAnswer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed0\",\"outputs\":[{\"internalType\":\"contract IAggregatorInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed1\",\"outputs\":[{\"internalType\":\"contract IAggregatorInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"sqrt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getPrice()\":{\"details\":\"This function fetches reserves from the AMM and uses a pre-defined price for tokens to calculate the LP token price.\",\"returns\":{\"price\":\"The price of the liquidity pool token.\"}},\"sqrt(uint256)\":{\"details\":\"This function uses an iterative method to compute the square root of a number.\",\"params\":{\"x\":\"The number to compute the square root of.\"},\"returns\":{\"y\":\"The square root of the given number.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getPrice()\":{\"notice\":\"Gets the price of the liquidity pool token.\"},\"latestAnswer()\":{\"notice\":\"Gets the latest price of the liquidity pool token.\"},\"sqrt(uint256)\":{\"notice\":\"Computes the square root of a given number using the Babylonian method.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/aerodrome/implementations/AEROUSDCvAMMOracle.sol\":\"AEROUSDCvAMMOracle\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20Metadata} from \\\"../token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\",\"keccak256\":\"0x00c23b80f74717a6765b606001c5c633116020d488ee8f53600685b8200e4bf3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xc6a8ff0ea489379b61faa647490411b80102578440ab9d84e9a957cc12164e70\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0xaa761817f6cd7892fcf158b3c776b34551cde36f48ff9703d53898bc45a94ea2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\",\"keccak256\":\"0x005ec64c6313f0555d59e278f9a7a5ab2db5bdc72a027f255a37c327af1ec02d\",\"license\":\"MIT\"},\"contracts/aerodrome/AerodromeVAMMOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\\\";\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport {IAggregatorInterface} from \\\"../interfaces/IAggregatorInterface.sol\\\";\\nimport {IAerodromeVAMM} from \\\"../interfaces/IAerodromeVAMM.sol\\\";\\n\\n/// @title Aerodrome_vAMM_Oracle\\n/// @notice This contract provides a price oracle for the liquidity pool tokens in a AMM.\\n/// @dev This contract interacts with the IAerodromeVAMM interface to fetch reserves and calculate prices.\\n/// @dev Reference from https://github.com/AlphaFinanceLab/alpha-homora-v2-contract/blob/master/contracts/oracle/UniswapV2Oracle.sol\\ncontract AerodromeVAMMOracle {\\n    using Math for uint256;\\n\\n    IAerodromeVAMM public immutable amm;\\n    IAggregatorInterface public immutable priceFeed0;\\n    IAggregatorInterface public immutable priceFeed1;\\n    uint256 public immutable offset;\\n\\n    address public immutable token0;\\n    address public immutable token1;\\n\\n    // uint256 private constant TWO_56 = 2 ** 56;\\n    // uint256 private constant TWO_112 = 2 ** 112;\\n    uint256 private constant HALF_UNIT = 1e9;\\n    uint256 private constant UNIT = 1e18;\\n\\n    /// @notice Constructor sets the address of the AMM contract.\\n    /// @param _amm The address of the AMM pool.\\n    constructor(\\n        address _amm,\\n        address _priceFeed0,\\n        address _priceFeed1,\\n        uint256 _offset\\n    ) {\\n        amm = IAerodromeVAMM(_amm);\\n        priceFeed0 = IAggregatorInterface(_priceFeed0);\\n        priceFeed1 = IAggregatorInterface(_priceFeed1);\\n        offset = _offset;\\n\\n        token0 = amm.token0();\\n        token1 = amm.token1();\\n    }\\n\\n    /// @notice Gets the price of the liquidity pool token.\\n    /// @dev This function fetches reserves from the AMM and uses a pre-defined price for tokens to calculate the LP token price.\\n    /// @return price The price of the liquidity pool token.\\n    function getPrice() public view returns (uint256 price) {\\n        (uint256 r0, uint256 r1, ) = amm.getReserves();\\n        uint256 totalSupply = amm.totalSupply();\\n\\n        uint256 px0 = getPx(priceFeed0, token0); // in 1e18\\n        uint256 px1 = getPx(priceFeed1, token1); // in 1e8\\n\\n        require(px0 > 0 && px1 > 0, \\\"Invalid Price\\\");\\n\\n        // fair token0 amt: sqrtK * sqrt(px1/px0)\\n        // fair token1 amt: sqrtK * sqrt(px0/px1)\\n        // fair lp price = 2 * sqrt(px0 * px1)\\n        // split into 2 sqrts multiplication to prevent uint overflow (note the 1e18)\\n        uint256 sqrtK_2 = fdiv(sqrt(r0 * r1), totalSupply) * 2; // in 1e18\\n        // uint256 numerator = ((sqrt(px0) / TWO_56) * sqrt(px1)) / TWO_56;\\n\\n        return (((sqrtK_2 * sqrt(px0)) / HALF_UNIT) * sqrt(px1)) / HALF_UNIT;\\n    }\\n\\n    /// @notice Gets the latest price of the liquidity pool token.\\n    function latestAnswer() public view returns (int256) {\\n        return int256(getPrice());\\n    }\\n\\n    /// @notice Computes the square root of a given number using the Babylonian method.\\n    /// @dev This function uses an iterative method to compute the square root of a number.\\n    /// @param x The number to compute the square root of.\\n    /// @return y The square root of the given number.\\n    function sqrt(uint256 x) public pure returns (uint256 y) {\\n        if (x == 0) return 0; // Handle the edge case for 0\\n        uint256 z = (x + 1) / 2;\\n        y = x;\\n        while (z < y) {\\n            y = z;\\n            z = (x / z + z) / 2;\\n        }\\n    }\\n\\n    function fdiv(uint256 lhs, uint256 rhs) internal pure returns (uint256) {\\n        return (lhs * UNIT) / rhs;\\n    }\\n\\n    function getPx(\\n        IAggregatorInterface oracle,\\n        address token\\n    ) public view returns (uint256) {\\n        uint8 decimals = IERC20Metadata(token).decimals();\\n        int256 answer = oracle.latestAnswer();\\n        return (uint256(answer) * UNIT) / (10 ** decimals);\\n    }\\n}\\n\",\"keccak256\":\"0x46fcc814d7ff18859ec918b8fb18c13b694f9a5ca0cf61b7a2cdbcec92b3a98f\",\"license\":\"MIT\"},\"contracts/aerodrome/implementations/AEROUSDCvAMMOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {AerodromeVAMMOracle} from \\\"../AerodromeVAMMOracle.sol\\\";\\n\\ncontract AEROUSDCvAMMOracle is AerodromeVAMMOracle {\\n    constructor()\\n        AerodromeVAMMOracle(\\n            0x6cDcb1C4A4D1C3C6d054b27AC5B77e89eAFb971d, // USDC/AERO LP Pool\\n            0x7e860098F58bBFC8648a4311b374B1D669a2bc6B, // USDC Chainlink Feed\\n            0x4EC5970fC728C5f65ba413992CD5fF6FD70fcfF0, // AERO Chainlink Feed\\n            1e10\\n        )\\n    {\\n        // nothing\\n    }\\n}\\n\",\"keccak256\":\"0xf47234564c3982c6a792b010b0b70b16e3a64914ecb871a32dca72847ad14b92\",\"license\":\"MIT\"},\"contracts/interfaces/IAerodromeVAMM.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\npragma solidity ^0.8.12;\\n\\ninterface IAerodromeVAMM {\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint256 _reserve0,\\n            uint256 _reserve1,\\n            uint256 _blockTimestampLast\\n        );\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n}\\n\",\"keccak256\":\"0xb399e119de6daea28e048c5f14a7f872b91378203b3e5802fcafd3d44003f463\",\"license\":\"MIT\"},\"contracts/interfaces/IAggregatorInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IAggregatorInterface {\\n    function decimals() external view returns (uint8);\\n\\n    function latestAnswer() external view returns (int256);\\n}\\n\",\"keccak256\":\"0x64ddd30c855ca2f5e11233b48be9c19e83596e6b9ac4c9469f0f5ca6dfe0bcf1\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6101406040523480156200001257600080fd5b50736cdcb1c4a4d1c3c6d054b27ac5b77e89eafb971d737e860098f58bbfc8648a4311b374b1d669a2bc6b734ec5970fc728c5f65ba413992cd5ff6fd70fcff06402540be4008373ffffffffffffffffffffffffffffffffffffffff1660808173ffffffffffffffffffffffffffffffffffffffff16815250508273ffffffffffffffffffffffffffffffffffffffff1660a08173ffffffffffffffffffffffffffffffffffffffff16815250508173ffffffffffffffffffffffffffffffffffffffff1660c08173ffffffffffffffffffffffffffffffffffffffff16815250508060e0818152505060805173ffffffffffffffffffffffffffffffffffffffff16630dfe16816040518163ffffffff1660e01b8152600401602060405180830381865afa1580156200014a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620001709190620002c0565b73ffffffffffffffffffffffffffffffffffffffff166101008173ffffffffffffffffffffffffffffffffffffffff168152505060805173ffffffffffffffffffffffffffffffffffffffff1663d21220a76040518163ffffffff1660e01b8152600401602060405180830381865afa158015620001f2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620002189190620002c0565b73ffffffffffffffffffffffffffffffffffffffff166101208173ffffffffffffffffffffffffffffffffffffffff168152505050505050620002f2565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600062000288826200025b565b9050919050565b6200029a816200027b565b8114620002a657600080fd5b50565b600081519050620002ba816200028f565b92915050565b600060208284031215620002d957620002d862000256565b5b6000620002e984828501620002a9565b91505092915050565b60805160a05160c05160e0516101005161012051610e2e6200036c6000396000818161059b01526106b30152600081816101f5015261054d015260006106d701526000818161057a015261068f01526000818161023d015261052c0152600081816102190152818161040001526104960152610e2e6000f3fe608060405234801561001057600080fd5b506004361061009e5760003560e01c8063677342ce11610066578063677342ce1461014b57806398d5fdca1461017b578063ab0ca0e114610199578063d21220a7146101b7578063d5556544146101d55761009e565b80630dfe1681146100a35780632a943945146100c1578063385aee1b146100df5780634815bf97146100fd57806350d25bcd1461012d575b600080fd5b6100ab6101f3565b6040516100b89190610763565b60405180910390f35b6100c9610217565b6040516100d691906107dd565b60405180910390f35b6100e761023b565b6040516100f49190610819565b60405180910390f35b610117600480360381019061011291906108a3565b61025f565b60405161012491906108fc565b60405180910390f35b61013561037b565b6040516101429190610930565b60405180910390f35b61016560048036038101906101609190610977565b61038a565b60405161017291906108fc565b60405180910390f35b6101836103f9565b60405161019091906108fc565b60405180910390f35b6101a161068d565b6040516101ae9190610819565b60405180910390f35b6101bf6106b1565b6040516101cc9190610763565b60405180910390f35b6101dd6106d5565b6040516101ea91906108fc565b60405180910390f35b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b6000808273ffffffffffffffffffffffffffffffffffffffff1663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156102ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102d191906109dd565b905060008473ffffffffffffffffffffffffffffffffffffffff166350d25bcd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610320573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103449190610a36565b905081600a6103539190610bc5565b670de0b6b3a7640000826103679190610c10565b6103719190610c81565b9250505092915050565b60006103856103f9565b905090565b600080820361039c57600090506103f4565b600060026001846103ad9190610cb2565b6103b79190610c81565b90508291505b818110156103f25780915060028182856103d79190610c81565b6103e19190610cb2565b6103eb9190610c81565b90506103bd565b505b919050565b60008060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16630902f1ac6040518163ffffffff1660e01b8152600401606060405180830381865afa158015610469573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061048d9190610cfb565b509150915060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156104ff573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105239190610d4e565b905060006105717f00000000000000000000000000000000000000000000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000061025f565b905060006105bf7f00000000000000000000000000000000000000000000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000061025f565b90506000821180156105d15750600081115b610610576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161060790610dd8565b60405180910390fd5b6000600261063161062b87896106269190610c10565b61038a565b866106f9565b61063b9190610c10565b9050633b9aca0061064b8361038a565b633b9aca006106598661038a565b846106649190610c10565b61066e9190610c81565b6106789190610c10565b6106829190610c81565b965050505050505090565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b600081670de0b6b3a7640000846107109190610c10565b61071a9190610c81565b905092915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061074d82610722565b9050919050565b61075d81610742565b82525050565b60006020820190506107786000830184610754565b92915050565b6000819050919050565b60006107a361079e61079984610722565b61077e565b610722565b9050919050565b60006107b582610788565b9050919050565b60006107c7826107aa565b9050919050565b6107d7816107bc565b82525050565b60006020820190506107f260008301846107ce565b92915050565b6000610803826107aa565b9050919050565b610813816107f8565b82525050565b600060208201905061082e600083018461080a565b92915050565b600080fd5b600061084482610742565b9050919050565b61085481610839565b811461085f57600080fd5b50565b6000813590506108718161084b565b92915050565b61088081610742565b811461088b57600080fd5b50565b60008135905061089d81610877565b92915050565b600080604083850312156108ba576108b9610834565b5b60006108c885828601610862565b92505060206108d98582860161088e565b9150509250929050565b6000819050919050565b6108f6816108e3565b82525050565b600060208201905061091160008301846108ed565b92915050565b6000819050919050565b61092a81610917565b82525050565b60006020820190506109456000830184610921565b92915050565b610954816108e3565b811461095f57600080fd5b50565b6000813590506109718161094b565b92915050565b60006020828403121561098d5761098c610834565b5b600061099b84828501610962565b91505092915050565b600060ff82169050919050565b6109ba816109a4565b81146109c557600080fd5b50565b6000815190506109d7816109b1565b92915050565b6000602082840312156109f3576109f2610834565b5b6000610a01848285016109c8565b91505092915050565b610a1381610917565b8114610a1e57600080fd5b50565b600081519050610a3081610a0a565b92915050565b600060208284031215610a4c57610a4b610834565b5b6000610a5a84828501610a21565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60008160011c9050919050565b6000808291508390505b6001851115610ae957808604811115610ac557610ac4610a63565b5b6001851615610ad45780820291505b8081029050610ae285610a92565b9450610aa9565b94509492505050565b600082610b025760019050610bbe565b81610b105760009050610bbe565b8160018114610b265760028114610b3057610b5f565b6001915050610bbe565b60ff841115610b4257610b41610a63565b5b8360020a915084821115610b5957610b58610a63565b5b50610bbe565b5060208310610133831016604e8410600b8410161715610b945782820a905083811115610b8f57610b8e610a63565b5b610bbe565b610ba18484846001610a9f565b92509050818404811115610bb857610bb7610a63565b5b81810290505b9392505050565b6000610bd0826108e3565b9150610bdb836109a4565b9250610c087fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8484610af2565b905092915050565b6000610c1b826108e3565b9150610c26836108e3565b9250828202610c34816108e3565b91508282048414831517610c4b57610c4a610a63565b5b5092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000610c8c826108e3565b9150610c97836108e3565b925082610ca757610ca6610c52565b5b828204905092915050565b6000610cbd826108e3565b9150610cc8836108e3565b9250828201905080821115610ce057610cdf610a63565b5b92915050565b600081519050610cf58161094b565b92915050565b600080600060608486031215610d1457610d13610834565b5b6000610d2286828701610ce6565b9350506020610d3386828701610ce6565b9250506040610d4486828701610ce6565b9150509250925092565b600060208284031215610d6457610d63610834565b5b6000610d7284828501610ce6565b91505092915050565b600082825260208201905092915050565b7f496e76616c696420507269636500000000000000000000000000000000000000600082015250565b6000610dc2600d83610d7b565b9150610dcd82610d8c565b602082019050919050565b60006020820190508181036000830152610df181610db5565b905091905056fea2646970667358221220f2825b1f6936f311addefe882d7662f0f71786ab058f16fae3861654b9a94d0564736f6c63430008140033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061009e5760003560e01c8063677342ce11610066578063677342ce1461014b57806398d5fdca1461017b578063ab0ca0e114610199578063d21220a7146101b7578063d5556544146101d55761009e565b80630dfe1681146100a35780632a943945146100c1578063385aee1b146100df5780634815bf97146100fd57806350d25bcd1461012d575b600080fd5b6100ab6101f3565b6040516100b89190610763565b60405180910390f35b6100c9610217565b6040516100d691906107dd565b60405180910390f35b6100e761023b565b6040516100f49190610819565b60405180910390f35b610117600480360381019061011291906108a3565b61025f565b60405161012491906108fc565b60405180910390f35b61013561037b565b6040516101429190610930565b60405180910390f35b61016560048036038101906101609190610977565b61038a565b60405161017291906108fc565b60405180910390f35b6101836103f9565b60405161019091906108fc565b60405180910390f35b6101a161068d565b6040516101ae9190610819565b60405180910390f35b6101bf6106b1565b6040516101cc9190610763565b60405180910390f35b6101dd6106d5565b6040516101ea91906108fc565b60405180910390f35b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b6000808273ffffffffffffffffffffffffffffffffffffffff1663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156102ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102d191906109dd565b905060008473ffffffffffffffffffffffffffffffffffffffff166350d25bcd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610320573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103449190610a36565b905081600a6103539190610bc5565b670de0b6b3a7640000826103679190610c10565b6103719190610c81565b9250505092915050565b60006103856103f9565b905090565b600080820361039c57600090506103f4565b600060026001846103ad9190610cb2565b6103b79190610c81565b90508291505b818110156103f25780915060028182856103d79190610c81565b6103e19190610cb2565b6103eb9190610c81565b90506103bd565b505b919050565b60008060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16630902f1ac6040518163ffffffff1660e01b8152600401606060405180830381865afa158015610469573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061048d9190610cfb565b509150915060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156104ff573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105239190610d4e565b905060006105717f00000000000000000000000000000000000000000000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000061025f565b905060006105bf7f00000000000000000000000000000000000000000000000000000000000000007f000000000000000000000000000000000000000000000000000000000000000061025f565b90506000821180156105d15750600081115b610610576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161060790610dd8565b60405180910390fd5b6000600261063161062b87896106269190610c10565b61038a565b866106f9565b61063b9190610c10565b9050633b9aca0061064b8361038a565b633b9aca006106598661038a565b846106649190610c10565b61066e9190610c81565b6106789190610c10565b6106829190610c81565b965050505050505090565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b7f000000000000000000000000000000000000000000000000000000000000000081565b600081670de0b6b3a7640000846107109190610c10565b61071a9190610c81565b905092915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061074d82610722565b9050919050565b61075d81610742565b82525050565b60006020820190506107786000830184610754565b92915050565b6000819050919050565b60006107a361079e61079984610722565b61077e565b610722565b9050919050565b60006107b582610788565b9050919050565b60006107c7826107aa565b9050919050565b6107d7816107bc565b82525050565b60006020820190506107f260008301846107ce565b92915050565b6000610803826107aa565b9050919050565b610813816107f8565b82525050565b600060208201905061082e600083018461080a565b92915050565b600080fd5b600061084482610742565b9050919050565b61085481610839565b811461085f57600080fd5b50565b6000813590506108718161084b565b92915050565b61088081610742565b811461088b57600080fd5b50565b60008135905061089d81610877565b92915050565b600080604083850312156108ba576108b9610834565b5b60006108c885828601610862565b92505060206108d98582860161088e565b9150509250929050565b6000819050919050565b6108f6816108e3565b82525050565b600060208201905061091160008301846108ed565b92915050565b6000819050919050565b61092a81610917565b82525050565b60006020820190506109456000830184610921565b92915050565b610954816108e3565b811461095f57600080fd5b50565b6000813590506109718161094b565b92915050565b60006020828403121561098d5761098c610834565b5b600061099b84828501610962565b91505092915050565b600060ff82169050919050565b6109ba816109a4565b81146109c557600080fd5b50565b6000815190506109d7816109b1565b92915050565b6000602082840312156109f3576109f2610834565b5b6000610a01848285016109c8565b91505092915050565b610a1381610917565b8114610a1e57600080fd5b50565b600081519050610a3081610a0a565b92915050565b600060208284031215610a4c57610a4b610834565b5b6000610a5a84828501610a21565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60008160011c9050919050565b6000808291508390505b6001851115610ae957808604811115610ac557610ac4610a63565b5b6001851615610ad45780820291505b8081029050610ae285610a92565b9450610aa9565b94509492505050565b600082610b025760019050610bbe565b81610b105760009050610bbe565b8160018114610b265760028114610b3057610b5f565b6001915050610bbe565b60ff841115610b4257610b41610a63565b5b8360020a915084821115610b5957610b58610a63565b5b50610bbe565b5060208310610133831016604e8410600b8410161715610b945782820a905083811115610b8f57610b8e610a63565b5b610bbe565b610ba18484846001610a9f565b92509050818404811115610bb857610bb7610a63565b5b81810290505b9392505050565b6000610bd0826108e3565b9150610bdb836109a4565b9250610c087fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8484610af2565b905092915050565b6000610c1b826108e3565b9150610c26836108e3565b9250828202610c34816108e3565b91508282048414831517610c4b57610c4a610a63565b5b5092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000610c8c826108e3565b9150610c97836108e3565b925082610ca757610ca6610c52565b5b828204905092915050565b6000610cbd826108e3565b9150610cc8836108e3565b9250828201905080821115610ce057610cdf610a63565b5b92915050565b600081519050610cf58161094b565b92915050565b600080600060608486031215610d1457610d13610834565b5b6000610d2286828701610ce6565b9350506020610d3386828701610ce6565b9250506040610d4486828701610ce6565b9150509250925092565b600060208284031215610d6457610d63610834565b5b6000610d7284828501610ce6565b91505092915050565b600082825260208201905092915050565b7f496e76616c696420507269636500000000000000000000000000000000000000600082015250565b6000610dc2600d83610d7b565b9150610dcd82610d8c565b602082019050919050565b60006020820190508181036000830152610df181610db5565b905091905056fea2646970667358221220f2825b1f6936f311addefe882d7662f0f71786ab058f16fae3861654b9a94d0564736f6c63430008140033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "getPrice()": {
        "details": "This function fetches reserves from the AMM and uses a pre-defined price for tokens to calculate the LP token price.",
        "returns": {
          "price": "The price of the liquidity pool token."
        }
      },
      "sqrt(uint256)": {
        "details": "This function uses an iterative method to compute the square root of a number.",
        "params": {
          "x": "The number to compute the square root of."
        },
        "returns": {
          "y": "The square root of the given number."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getPrice()": {
        "notice": "Gets the price of the liquidity pool token."
      },
      "latestAnswer()": {
        "notice": "Gets the latest price of the liquidity pool token."
      },
      "sqrt(uint256)": {
        "notice": "Computes the square root of a given number using the Babylonian method."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}